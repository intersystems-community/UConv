<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25">
<Routine name="exportGlobal" type="MAC" languagemode="0"><![CDATA[
#include Globs
#include %occStatus
Start(ary,link)  
  set SockFlag=0
  SET file = ##class(%Stream.FileCharacter).%New()
  SET blocksWritten = 0, buffer=""
  set file.Filename=link, file.RemoveOnClose=0
  set sock=##class(%IO.Socket).%New(), sock.TranslationTable="UTF8"
  do sock.Open(link,"7031",1,.sc)
  if ($$$ISOK(sc)) { set file=sock, SockFlag=1 }
  set queryary=ary
  try {set TrashValue=@queryary} catch {set queryary = $QUERY(@queryary)} //
  FOR   {
        	q:queryary=""  
        	set node = ##class(Globals.Utils).nodeToStr(queryary) //получаем 1 строчку из 1 узла
	       	set blocksWritten = (blocksWritten + ##class(Globals.Utils).ChunkAndSend(node,.buffer, file, SockFlag))	//обрабатываем строчку(encode + ->buf/->send)
			SET queryary=$QUERY(@queryary)  	
  }
  	//Записываем оставшийся кусок
  	if (SockFlag) do file.ReadAny(3) 
  	set tempstr2=##class(Globals.Utils).Encode(buffer)
  	set trashStr =tempstr2
  	f i=1:1:($$$BLOCKSIZE-$l(tempstr2)) {set trashStr=(trashStr_"0")}
	do file.Write(trashStr)
	set blocksWritten = blocksWritten+1
	if (SockFlag) do file.ReadAny(3) 
	d file.Write("")
  WRITE !,"Finished. Blocks written: ", blocksWritten
  if ('SockFlag) { d file.%Save() }
  else { d sock.Close() }
  d file.%Close()
  
]]></Routine>
</Export>
