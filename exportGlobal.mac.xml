<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25">
<Routine name="exportGlobal" type="MAC" languagemode="0"><![CDATA[
#include Globs
#include %occStatus
Start(ary,file,SockFlag, buffer) 
	set buffer=""
	w !, "Going to export ",ary," to ",link,! 
  set queryary=ary
  try {set TrashValue=@queryary} catch {set queryary = $QUERY(@queryary)} //
  set oldBW=""
  FOR   {
        	q:queryary=""  
        	set node = ##class(Globals.Utils).nodeToStr(queryary) //получаем 1 строчку из 1 узла
	       	set blocksWritten = (blocksWritten + ##class(Globals.Utils).ChunkAndSend(node,.buffer, file, SockFlag))	//обрабатываем строчку(encode + ->buf/->send)
			if (blocksWritten>(oldBW+$$$BLOCKTICK))
			{
				set oldBW=blocksWritten
				w $c(13), "                                          "
				w $c(13),"Current blocks sent :", $c(9),blocksWritten
			}
			SET queryary=$QUERY(@queryary)  	
  }
  	//Записываем оставшийся кусок
  
	set tempstr2=##class(Globals.Utils).Encode(buffer)
		  	set length=##class(Globals.Utils).ValueToWord($l(tempstr2))
		  	set ll=##class(Globals.Utils).Encode(length)
		  	//set ll=""
		  	//for j=1:1:$l(length) 
		  	//{
			//  	if ($zh($a($e(length,j)))="0") { set ll=ll_"00" }
			//  	else {set ll=ll_$zh($a($e(length,j)))}
		  	//}
		  	if (SockFlag) { do file.Write(ll, $$$YES) }
		  	else {do file.Write(ll) }
			if (SockFlag) do file.ReadAny(3)
			
			if (SockFlag) { do file.Write(tempstr2, $$$YES) }
		  	else { do file.Write(tempstr2)}
			set blocksWritten = (blocksWritten+1) 
		  	if (SockFlag) do file.ReadAny(3)
		  	w "..finished, blocks: ", blocksWritten
		  	q 
		  	
Final(ary,file,SockFlag,buffer) 
	d file.Write("")
  WRITE !,"Finished."
  if ('SockFlag) { d file.%Save() }
  else { d sock.Close() }
  d file.%Close()
  k file
  
]]></Routine>
</Export>
